# -*- coding: utf-8 -*-
"""Movie_recommander_system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uHOWgu7v-JMgTIR1TERTHUdQ1T5vgCpD

# 1. Importing Libraries
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
import tensorflow as tf
from sklearn.metrics import r2_score, root_mean_squared_error
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
import joblib

"""# 2- Importing the dataset"""

ratings_df = pd.read_csv('./rating.csv')
movies_df = pd.read_csv('./movie.csv')

ratings_df = ratings_df.drop(columns=['timestamp'])
movies_df = movies_df.drop(columns=['title'])

print(ratings_df.head(1))
print(movies_df.head(1))

ratings_df.describe()

ratings_df = ratings_df.merge(movies_df, on='movieId')
ratings_df['genres'] = ratings_df['genres'].str.split('|')

"""# 3. Model params"""

users_embedding_size, movies_embedding_size = 25, 25
genre_embedding_size = 5

"""# 4. Converting Movie/User IDs to Indexes"""

def genre_pooling(genre_df):
    genre_dict = {}
    id = 1

    # First, create a mapping of genres to unique IDs
    for genres in genre_df:
        for genre in genres:
            if genre not in genre_dict:
                genre_dict[genre] = id
                id += 1

    # Convert genres into their respective unique IDs
    converted_genre = genre_df.apply(lambda genres: [genre_dict[genre] for genre in genres])

    # Apply pooling: mean of the genre IDs for each movie
    pooled_genre = converted_genre.apply(np.mean)

    return pooled_genre

pooled_genres = genre_pooling(ratings_df['genres'])
pooled_genres = np.array(pooled_genres).reshape(-1, 1)

"""# 5. Data splitting"""

print(len(ratings_df), pooled_genres.shape)
train_user, test_user, train_movie, test_movie, train_genre, test_genre, train_y, test_y = train_test_split(
    ratings_df['userId'], ratings_df['movieId'], pooled_genres, ratings_df['rating'],
    test_size=0.2, random_state=42
)

print(pooled_genres.shape)
# del ratings_df
# del movies_df
# del pooled_genres

user_encoder = LabelEncoder()
user_enc = user_encoder.fit_transform(ratings_df['userId'])

movie_encoder = LabelEncoder()
movie_enc = movie_encoder.fit_transform(ratings_df['movieId'])

num_users = len(user_enc)
num_movies = len(movie_enc)

"""# 6. Input and Embedding layers creation"""

user_input = tf.keras.Input(shape=(1,), name='user_input')
movie_input = tf.keras.Input(shape=(1,), name='movie_input')
genre_input = tf.keras.Input(shape=(1,), name='genre_input')


user_embedding = tf.keras.layers.Embedding(
    input_dim=num_users + 1,  # +1 because IDs start from 1
    output_dim=users_embedding_size,
    embeddings_initializer='uniform',
    name='user_embedding',
)(user_input)

movie_embedding = tf.keras.layers.Embedding(
    input_dim=num_movies + 1,
    output_dim=movies_embedding_size,
    embeddings_initializer='uniform',
    name='movie_embedding',
)(movie_input)

"""# 7. Layers Setup"""

# Flatten embeddings to 2D
user_vec = tf.keras.layers.Flatten()(user_embedding)
movie_vec = tf.keras.layers.Flatten()(movie_embedding)
# Concatenate user and movie vectors
concat = tf.keras.layers.Concatenate()([user_vec, movie_vec, genre_input])

# Dense layers
x = tf.keras.layers.Dense(
    128,
    activation='relu',)(concat)
x = tf.keras.layers.Dense(
    32,
    activation='relu',)(x)
x = tf.keras.layers.Dense(
    16,
    activation='relu',)(x)
output = tf.keras.layers.Dense(1, activation='linear')(x)

"""# 8. Model compilation"""

model = tf.keras.Model(inputs=[user_input, movie_input, genre_input], outputs=output)
optimizer = tf.keras.optimizers.Adam(learning_rate=.0005)

# 5. Compile model
model.compile(
    optimizer=optimizer,
    loss='mse',
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""# 9. Model training"""

model.summary()

# 6. Train model
history = model.fit(
    [train_user, train_movie, train_genre],
    train_y,
    validation_split=0.1,
    epochs=20,
    batch_size=256,
    verbose=1
)

"""# 10. Model Evaluation"""

# 7. Evaluate
pred_y = model.predict([test_user, test_movie, test_genre])
r2 = r2_score(test_y, pred_y)
rmse = root_mean_squared_error(test_y, pred_y)
print(f'RÂ² score: {r2:.3f}, RMSE: {rmse:.3f}')

"""# 11. Model Save"""

model.save('cf_mlp_embedding.h5')